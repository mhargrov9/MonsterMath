Do not write any code. Review these instructions and let me know if it fits our overall strategy and if it violates any of the unbreakable rules (without writing code). Also, please let me know if you think this will solve the following problems:

Problem: The handleStartOfTurn function does not process the 'DISRUPTION' effect_type, rendering the CONFUSED status effect meaningless.

Goal: Enhance the handleStartOfTurn function to correctly process the CONFUSED status effect. The function must read both the chance and the self-damage modifier from the database to determine the outcome.

File Modifications
1. server/battleEngine.ts

Action: Locate and completely replace the existing handleStartOfTurn function with the following new code. This new version refactors the logic into a more scalable switch statement and adds the full implementation for the CONFUSED effect.

Replacement Code:

TypeScript

const handleStartOfTurn = (battleState: any, isPlayerTurn: boolean): { turnSkipped: boolean } => {
  const currentTeam = isPlayerTurn ? battleState.playerTeam : battleState.aiTeam;
  const activeIndex = isPlayerTurn ? battleState.activePlayerIndex : battleState.activeAiIndex;
  const activeMonster = currentTeam[activeIndex];
  const teamName = isPlayerTurn ? "Your" : "Opponent's";

  if (activeMonster.statusEffects && activeMonster.statusEffects.length > 0) {
    for (const effect of activeMonster.statusEffects) {
      if (!effect.effectDetails) continue;

      switch (effect.effectDetails.effect_type) {
        case 'TURN_SKIP': { // For PARALYZED
          battleState.battleLog.push(
            `${teamName} ${activeMonster.monster?.name || activeMonster.name} is paralyzed and can't move!`,
          );
          return { turnSkipped: true };
        }

        case 'DISRUPTION': { // For CONFUSED
          // Read chance from the database (default_value), with a fallback.
          const confusionChance = parseFloat(effect.override_chance || effect.effectDetails.default_value || '0.5');

          if (Math.random() < confusionChance) {
            const monsterName = activeMonster.monster?.name || activeMonster.name;
            // Read self-damage modifier from the database (secondary_value), with a fallback.
            const selfDamageModifier = parseFloat(effect.effectDetails.secondary_value || '0.4');

            // Calculate self-damage based on the monster's own power stat.
            const selfDamage = Math.floor(activeMonster.power * selfDamageModifier);

            if (selfDamage > 0) {
                activeMonster.battleHp = Math.max(0, activeMonster.battleHp - selfDamage);
                battleState.battleLog.push(
                  `${teamName} ${monsterName} is confused and hurt itself for ${selfDamage} damage!`,
                );
            }

            // The turn is skipped after self-damage.
            return { turnSkipped: true };
          }
          break; // If confusion check fails, do nothing and proceed.
        }
      }
    }
  }

  battleState.battleLog.push(`${teamName} ${activeMonster.monster?.name || activeMonster.name}'s turn begins!`);
  return { turnSkipped: false };
};