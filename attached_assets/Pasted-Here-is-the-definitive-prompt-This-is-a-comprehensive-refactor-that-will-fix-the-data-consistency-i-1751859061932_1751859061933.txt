Here is the definitive prompt. This is a comprehensive refactor that will fix the data consistency issues at their core.

Do not write any code. Review these instructions and let me know if it fits our overall strategy and if it violates any of the unbreakable rules (without writing code). Also, please let me know if you think this will solve the following problems:

Problem 1: Game-Breaking Crash: The application crashes when a player attacks or swaps due to data corruption of the AI monster object between turns.

Problem 2: Incorrect Status Effect Duration: Status effects like PARALYZED last for one turn longer than intended due to an off-by-one error in the countdown logic.

Problem 3: Illogical Battle Log Order: Combat effectiveness messages (e.g., "It's not very effective...") appear in the battle log before the action that caused them.

Problem 4: Insufficient Test Coverage: The test suite lacks a multi-turn integration test that can catch state corruption bugs over the course of a battle.

Goal:
To perform a complete audit and refactor of server/battleEngine.ts to enforce a single, consistent data-handling paradigm. This will fix all known data-related bugs. We will also enhance server/battleEngine.test.ts with a new multi-turn test to prevent future data corruption regressions.

Files to Modify:
server/battleEngine.ts

server/battleEngine.test.ts

Implementation Plan:
Part 1: The Engine Refactor (server/battleEngine.ts)
Refactor createBattleSession:

Action: The logic for creating the abilities_map is flawed. It must be keyed by the unique instance ID of each monster, not the template ID.

First, collect all the numeric template IDs from both the player and AI teams (monster.monster.id).

Use these template IDs to fetch all abilities from the database in a single call: const abilitiesByTemplateId = await storage.getAbilitiesForMonsters(allTemplateIds);.

Next, create the final battleState.abilities_map. Iterate through the playerTeam and aiTeam again. For each monster, use its unique instance ID (monster.id) as the key, and assign the abilities from the abilitiesByTemplateId map using its template ID (monster.monster.id) as the lookup.

This ensures battleState.abilities_map is correctly keyed by unique instance IDs (e.g., 101, 'ai-6-5').

Refactor handleEndOfTurn:

Action: Simplify the status effect duration logic to fix the off-by-one error.

In the loop that processes monster.statusEffects, delete the entire if (effect.isNew) / else block.

Replace it with a simple, unconditional decrement for every effect: effect.duration -= 1;. This ensures the countdown starts on the turn the effect is applied.

Refactor executeAbility:

Action 1 (Fix Target Crash): The logic to find the defender is brittle. Add validation. Immediately after defining const defender = defendingTeam[defenderIndex];, add a guard clause: if (!defender) { throw new Error(...) }.

Action 2 (Fix Log Order): Find the block of code that pushes messages to the battleState.battleLog. Ensure the main action message (...used [Ability] on [Defender], dealing [X] damage!) is pushed to the log before any secondary messages like It's super effective! or A critical hit!.

Refactor processAiTurn:

Action: The ability lookup logic is using the wrong ID.

Find the line: const monsterAbilities = battleState.abilities_map[aiMonster.monster.id] || [];.

This is incorrect because the map is now keyed by the unique instance ID. Change it to use the correct key: const monsterAbilities = battleState.abilities_map[aiMonster.id] || [];.

Part 2: The Test Suite Enhancement (server/battleEngine.test.ts)
Add the "Golden" Test:

Action: Add a new integration test to a new or existing describe block.

Name: "should maintain AI monster data structure over multiple turns".

Logic:

Setup a battle state with a player monster and an AI monster.

Simulate a player turn by calling applyDamage.

Simulate an AI turn by calling processAiTurn.

Simulate a second player turn by calling applyDamage again.

Get the final battleState and assert that the AI monster's nested data is intact:

TypeScript

const finalAiMonster = finalState.aiTeam[finalState.activeAiIndex];
expect(finalAiMonster.monster).toBeDefined();
expect(finalAiMonster.monster.name).toBe('Test AiMon');