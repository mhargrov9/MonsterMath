Do not write any code. Review these instructions and let me know if it fits our overall strategy and if it violates any of the unbreakable rules (without writing code). Also, please let me know if you think this will solve the following problems:

Problem: The handleStartOfTurn function does not handle the 'DISRUPTION' effect_type, which means the CONFUSED status has no gameplay effect.

Goal: Enhance the handleStartOfTurn function to correctly process the CONFUSED status effect. A confused monster must always damage itself based on a database value and skip its turn.

File Modifications
1. server/battleEngine.ts

Action: Locate and completely replace the existing handleStartOfTurn function with the following new code.

Replacement Code:

TypeScript

const handleStartOfTurn = (battleState: any, isPlayerTurn: boolean): { turnSkipped: boolean } => {
  const currentTeam = isPlayerTurn ? battleState.playerTeam : battleState.aiTeam;
  const activeIndex = isPlayerTurn ? battleState.activePlayerIndex : battleState.activeAiIndex;
  const activeMonster = currentTeam[activeIndex];
  const teamName = isPlayerTurn ? "Your" : "Opponent's";

  if (activeMonster.statusEffects && activeMonster.statusEffects.length > 0) {
    for (const effect of activeMonster.statusEffects) {
      if (!effect.effectDetails) continue;

      switch (effect.effectDetails.effect_type) {
        case 'TURN_SKIP': { // For PARALYZED
          battleState.battleLog.push(
            `${teamName} ${activeMonster.monster?.name || activeMonster.name} is paralyzed and can't move!`,
          );
          return { turnSkipped: true };
        }

        case 'DISRUPTION': { // For CONFUSED
          // Read chance from the database (which we set to 1.0 for 100%).
          const confusionChance = parseFloat(effect.override_chance || effect.effectDetails.default_value || '0.5');

          if (Math.random() < confusionChance) {
            const monsterName = activeMonster.monster?.name || activeMonster.name;
            // Read self-damage modifier from the database's secondary_value field.
            const selfDamageModifier = parseFloat(effect.effectDetails.secondary_value || '0.4');

            // Calculate self-damage based on the monster's own power stat.
            const selfDamage = Math.floor(activeMonster.power * selfDamageModifier);

            if (selfDamage > 0) {
                activeMonster.battleHp = Math.max(0, activeMonster.battleHp - selfDamage);
                battleState.battleLog.push(
                  `${teamName} ${monsterName} is confused and hurt itself for ${selfDamage} damage!`,
                );
            }

            // The turn is skipped after self-damage.
            return { turnSkipped: true };
          }
          break; 
        }
      }
    }
  }

  battleState.battleLog.push(`${teamName} ${activeMonster.monster?.name || activeMonster.name}'s turn begins!`);
  return { turnSkipped: false };
};